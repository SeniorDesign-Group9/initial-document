\subsection{Controller Subsystem}
\label{sec:controller_subsystem}
\begin{figure}[H]
    \label{mcu_block_diagram}
    \caption{MCU block diagram}
    \centering
    % Need to update block diagram
    \includegraphics[width=0.75\textwidth]{images/mcu_block_diagram.png}
\end{figure}
% I need to write 11 pages lmfao
% 4 more pages (page total 27)
\begin{flushleft}
    % Why the MCU connects to the internet
    In order for our system to be as self-sufficient and power efficient as
    possible from an end-user perspective, it was determined that our system
    would require an internet connection to offload remote command-and-control
    to an Amazon Web Services EC2 instance (hence referred to as "AWS" and detailed in
    \autoref{sec:web_subsystem}). To make the process of operating our product 
    as hands-off as possible to end-users, the microcontroller will connect to
    the user's home WiFi network for access to AWS. Bluetooth, Zigbee, Thread,
    and other short-range 2.4 GHz communication protocols were disfavored over
    WiFi, as we predict most users will not have a device to dedicate to
    connecting our product via such protocols. Long range (LoRa) protocols were
    deemed unncessary, as the intended placement of our product is outside, 
    near or next to the user's home. We do not expect our product to produce
    or receive large amounts of data, so the decreased bandwidth of a
    WiFi-enabled product being beyond the outdoor walls of a building
    is not a significant drawback to our application. A wired connection
    (802.3/Ethernet) was deemed too invasive to the end-user. It is expected
    that most, if not all, end-users have a wireless access point and internet
    access. Thus, connection via the 802.11/WiFi standard was a natural choice
    for our use case.
    % maybe diagram of chip or network stack?
\end{flushleft}
\begin{flushleft}
    % How the MCU connects to the internet (local network, LAN -> NAT -> WAN,
    % TCP stack)
    The Texas Instruments CC3220-series of microcontrollers are WiFi-enabled
    chips with an ARM Cortex-M4 central processor and a WiFi network processor,
    along with many useful peripherals and power management modules. The WiFi
    network processor supports the following standards/features useful to our
    development:
    \begin{itemize}
        \item WiFi standards: 802.11b/g/n
        \item WiFi security: WEP, WPA/WPA2 PSK, WPA2 enterprise, WPA3 personal,
        WPA3 enterprise
        \item WiFi provisioning: SmartConfig, WPS2
        \item IP protocols: IPv4, IPv6
        \item IP addressing: static IP, DHCPv4, DHCPv6
        \item Transport: UDP, TCP, RAW
        \item Host interface: UART, SPI
        \item Built-in transceiver and 2.4 GHz antenna
    \end{itemize}
    Our microcontroller will 
    % WHAT KIND OF INTERFACE????
    % option a) web interface for user to long in to WLAN
    % option b) WPS button
    % don't forget IP addressing (most likely DHCP)
    % Interim: hardcode network login
\end{flushleft}
\begin{flushleft}
    % TCP sockets
    The MCU will communicate with AWS through TCP sockets. After connection to
    the user's home network, the MCU will check if there is an internet
    connection. Once an internet connection has been established, the MCU will
    open a socket and connect to the AWS instance via its URL (using the
    default DNS nameserver provided to network clients).
\end{flushleft}
\begin{flushleft}
    % Parameters for connection and how often it tries
    Once the MCU has established a connection to the internet and the AWS
    instance, it attempts to send current system settings and telemetry, as
    well as sensor readings to AWS. The microcontroller does this at least
    once every 15 minutes. Sending and receiving may occur more often if
    commanded to by AWS. Because TCP is being used to connect AWS and the
    microcontroller, any manual retries on a failed send or receive most
    likely will be futile. Therefore, any sort of link error handling will
    be performed by the link and not the microcontroller program.
\end{flushleft}
\begin{flushleft}
    % Any over-the-air updates?
    At this time, our team does not intend to provide a method for over-the-air
    updates (OTA), however, this is a provision that may be developed in the
    future.
\end{flushleft}
\begin{flushleft}
    % MCU receives commands, decodes commands
    The MCU will receive commands and data from AWS in the following form:
    \begin{center}
        \texttt{t x c y}
    \end{center}
    where \texttt{t} (character) marks the beginning of the command string,
    \texttt{x} (unsigned integer) indicates how many seconds to wait before
    executing command \texttt{c} (character) with parameter \texttt{y}
    (ambiguous). The following characters occupy the spot of \texttt{c}, and
    translate to the following commands:
    \begin{center}
        \texttt{w y}: water, \texttt{y} is boolean \\
        \texttt{a y}: solar $\theta$, \texttt{y} is double \\
        \texttt{b y}: solar $\phi$, \texttt{y} is double \\
        \texttt{l y}: low power, \texttt{y} is unsigned int for flags \\
        \texttt{s y}: send data, \texttt{y} is unsigned int for flags
    \end{center}
    For example, if AWS instructs the MCU to turn on the water source in 3
    minutes, it would send the command \texttt{t 180 w 1}. If AWS would like
    the MCU to change the $\theta$ of the solar panels to 45$\degree$
    immediately, it would send \texttt{t 0 a 45.0}. It is important to note
    that the values of \texttt{x} and \texttt{y} are not strings (e.g.
    45$\degree$ will not be sent as \texttt{"45.0"}), but the actual encoding
    of 45$\degree$ as a double-precision float. This is to maintain a
    consistent command string size amongst all transmissions.
    \begin{figure}[H]
        \label{command_bitwise}
        \caption{Bitwise representation of command}
        \centering
        \includegraphics[width=0.75\textwidth]{images/command_encoding.png}
    \end{figure}
\end{flushleft}
\begin{flushleft}
    % Will program in C++. Any libraries, multithreading?
    % Singleton Pattern Thread for scheduling tasks
    It should be expected that all headers from the C++ standard library (as
    defined in C++23) will be used, along with the following nonstandard
    libraries: Texas Instruments SimpleLinkâ„¢ CC32xx SDK. Additionally, it is
    expected that the MCU program will schedule tasks using a Singleton Pattern
    thread to ensure thread safety when accessing variables.
\end{flushleft}
\begin{flushleft}
    % Classes and class diagram
    There will be a few classes defined in the MCU's programming.
    \begin{figure}[H]
        \label{classes_uml}
        \caption{UML diagram of the classes used}
        \centering
        \includegraphics[width=0.75\textwidth]{images/classes_uml.png}
    \end{figure}
    Classes will be laid out in a header file using the following defintions:
    \begin{flushleft}
        \texttt{class Plant \{}  \\
        \quad\texttt{private:} \\
        \quad\quad\texttt{bool water\_active;} \\
        \quad\quad\texttt{double temp;} \\
        \quad\quad\texttt{double moisture;} \\
        \quad\quad\texttt{uint32\_t oh\_comp;} \\
        \quad\quad\texttt{uint32\_t nutrients;} \\
        \quad\texttt{public:} \\
        \quad\quad\texttt{Plant();} \\
        \quad\quad\texttt{$\sim$Plant();} \\
        \quad\quad\texttt{set\_water\_active();} \\
        \quad\quad\texttt{get\_water\_active();} \\
        \quad\quad\texttt{set\_temp();} \\
        \quad\quad\texttt{get\_temp();} \\
        \quad\quad\texttt{set\_moisture();} \\
        \quad\quad\texttt{get\_moisture();} \\
        \quad\quad\texttt{set\_oh\_comp();} \\
        \quad\quad\texttt{get\_oh\_comp();} \\
        \quad\quad\texttt{get\_oh\_comp\_raw();} \\
        \quad\quad\texttt{set\_nutrients();} \\
        \quad\quad\texttt{get\_nutrients();} \\
        \quad\quad\texttt{get\_nutrients\_raw();} \\
        \texttt{\};} \\
    \end{flushleft}
    \begin{flushleft}
        \texttt{class Solar \{}  \\
        \quad\texttt{private:} \\
        \quad\quad\texttt{double theta;} \\
        \quad\quad\texttt{double phi;} \\
        \quad\quad\texttt{double voltage;} \\
        \quad\texttt{public:} \\
        \quad\quad\texttt{Solar();} \\
        \quad\quad\texttt{$\sim$Solar();} \\
        \quad\quad\texttt{set\_theta();} \\
        \quad\quad\texttt{get\_theta();} \\
        \quad\quad\texttt{set\_phi();} \\
        \quad\quad\texttt{get\_phi();} \\
        \quad\quad\texttt{set\_voltage();} \\
        \quad\quad\texttt{get\_voltage();} \\
        \texttt{\};} \\
    \end{flushleft}
    \begin{flushleft}
        \texttt{class Web \{}  \\
        \quad\texttt{private:} \\
        \quad\quad\texttt{string ip;} \\
        \quad\quad\texttt{int port;} \\
        \quad\texttt{public:} \\
        \quad\quad\texttt{Web();} \\
        \quad\quad\texttt{$\sim$Web();} \\
        \quad\quad\texttt{set\_ip();} \\
        \quad\quad\texttt{get\_ip();} \\
        \quad\quad\texttt{set\_port();} \\
        \quad\quad\texttt{get\_port();} \\
        \quad\quad\texttt{receive();} \\
        \quad\quad\texttt{send();} \\
        \texttt{\};} \\
    \end{flushleft}

    % Turn structs into classes
    % Get rid of telemetry
    % Implement default state
\end{flushleft}
\begin{flushleft}
    % Send to AWS, format and types of commands
    % Send straight data from the struct
    Unlike commands received from AWS, the MCU will simply send data directly
    from its classes to AWS. This is done to minimize the overhead of sending
    extraneous symbols and preserve power stored in the battery, as receiving
    uses far less power than transmitting in the MCU subsystem. Further
    optimization can be performed in the future to further reduce overhead
    (e.g. reducing \texttt{water\_active} to occupy 1 bit and using the rest of
    the symbol to encode other data).
    \begin{figure}[H]
        \label{toweb_encoding}
        \caption{Bitwise representation of data sent to AWS}
        \centering
        \includegraphics[width=0.75\textwidth]{images/toweb_encoding.png}
    \end{figure}
\end{flushleft}
\begin{flushleft}
    % Global vars
    No global variables plan to be implemented at this time.
\end{flushleft}
\begin{flushleft}
    % Functions
\end{flushleft}
\begin{flushleft}
    % Interrupts and ISRs
    If the charge controller indicates that the battery has fallen below a
    certain voltage (named "low voltage"), the MCU will raise an interrupt and
    execute \texttt{isr\_low\_power()}. This ISR performs housekeeping before
    putting the MCU into a low power state, limiting use of its functions.
\end{flushleft}
\begin{flushleft}
    % Interrupts and ISRs (cont.)
    If the charge controller indicates that the battery has fallen below a
    certain voltage (named "critical voltage"), the MCU will raise an interrupt
    and execute \texttt{isr\_critical\_power()}. This ISR performs further 
    housekeeping before putting the MCU into an extreme low power state,
    limiting all but the features necessary to maintain a connection with AWS.
\end{flushleft}
\begin{flushleft}
    % Interrupts and ISRs (cont.)
    If the MCU, AWS, or any other devices transmit indication of a dangerous
    state or if the MCU, AWS, or any other devices transmit indication of a
    shut down the MCU will raise an interrupt and execute
    \texttt{isr\_shut\_down()}. This ISR immediately shuts down all able
    subsystems, and puts all other subsystems in a fail safe state. This ISR
    fails safe the entire system.
\end{flushleft}
\begin{flushleft}
    % Interrupts and ISRs (cont.)
    If the MCU receives indication of a start up (via a momentary switch), the
    MCU will raise an interrupt and execute \texttt{isr\_start\_up()}. This ISR
    starts up all relevant subsystems and begins the MCU's programming. All
    classes will be initialized to default values. This ISR starts up the
    entire system.
\end{flushleft}
\begin{flushleft}
    % Interrupts and ISRs (cont.)
    If the MCU determines it must reset the system to a default state, the
    MCU will raise an interrupt and execute \texttt{isr\_default\_state()}.
    This ISR returns all relevant subsystems to their default state, almost
    as if the MCU had just executed \texttt{isr\_start\_up()}. All classes will
    be initialized to default values. This ISR resets the entire system.
\end{flushleft}
\begin{flushleft}
    % File organization (main, header files, other source files, etc.)
\end{flushleft}
\begin{flushleft}
    % How the MCU gets data from sensors (ADC)
\end{flushleft}
\begin{flushleft}
    % How MCU sends data to servos
\end{flushleft}
\begin{flushleft}
    % What sort of telemetry we'll have
    No data that would be exclusively considered telemetry will be transmitted 
    between AWS and the MCU (e.g. processor temperature). Instead, all
    "telemetry" values will be handled with interrupts and ISRs/functions
    on-chip, while current settings and sensor readings will be transmitted
    back to AWS.
\end{flushleft}
\begin{flushleft}
    % What kind of development model?
    % Probably agile
    An Agile development model will be used. Code reviews will be performed on
    an as-needed basis by a convening of members of the MCU subsystem and the
    websubsystem teams.
    \begin{figure}[H]
        \label{mcu_agile_uml}
        \caption{UML diagram of the project's development methodology}
        \centering
        \includegraphics[width=0.75\textwidth]{images/mcu_agile_uml.png}
    \end{figure}
\end{flushleft}
\begin{flushleft}
    % IDE and Git
    Texas Instruments Code Composer Studio v12 will be used to program,
    compile (via TI ARM compiler v20), and debug the C++-based project. GitHub
    will be used as a repository for the project, using Git for version
    control.
\end{flushleft}